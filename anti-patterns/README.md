#### Table of Contents

- [Components name should be capitilize](#components-name)
- [Breaking pure rendering](#breaking-pure-rendering)
- [Using index as a key prop](#using-index-as-key-prop)
- [Unconditionally copying props to state](#unconditionally-copying-props-to-state)
- [Erasing state when props change](#erasing-state-when-props-change)
- [Using state with shallow comparison](#using-state-with-shallow-comparison)

#### Components Name

Component name should be with a capital letter. Only HTML elements and SVG tags can begitn with a lowercase.

> You can ommit this rule by combining export/import functionality

```javascript
const alertMessage = (prop) => (
  <div className="alert-message">{prop.children}</div>
);

export default alertMessage;
```

> And then import it by using a new name

```javascript
import AlertMessage from "alertMessage";

<AlertMessage>This is an alert message!</AlertMessage>;
```

#### Breaking pure rendering

When you create a new instance it's completely destroyed every pure render optimization inside the Child elements.

> In JavaScript dirrerent instances have different identities and thus the shallow equality check always produces false and tells React to re-render the components.

> Don't create function inside render method! Functions create identities too

```javascript
const Element = (props) => (
  <input {...props} onChange={(e) => props.update(e.target.value)} />
);
```

> or

```javascript
class Element extends PureComponent {
  update(e) {
    this.props.update(e.target.value);
  }
  render() {
    return <Input onChange={this.update.bind(this)} />;
  }
}
```

> > The solution is

```javascript
class Element extends PureComponent {
  constructor(props) {
    super(props);
    this.update = this.update.bind(this);
  }
  update(e) {
    this.props.update(e.target.value);
  }
  render() {
    return <Input onChange={this.update} />;
  }
}
```

> > or to use class instance field sytax

```javascript
class Element extends PureComponent {
  update = (e) => {
    this.props.update(e.target.value);
  };
  render() {
    return <Input onChange={this.update} />;
  }
}
```

> Don't instantiate an object inside render method!

```javascript
const Table = (props) => (
  <div>
    {props.items.map((item) => (
      <Cell options={props.options || []} />
    ))}
  </div>
);
```

> > The solution is

```javascript
const default = [];
const Table = (props) => (
  <div>
    {props.items.map((item) => (
      <Cell options={props.options || default} />
    ))}
  </div>
);
```

[More details here](https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f#.hv3l5i8vb)

#### Using index as key prop

Using certain set of values such as array indexes may break your application or render wrong data. If two elements have same keys, React considers them same.

> Random numbers or timestamps should not be used as keys. The component will be re-rendered every time even if the content inside the element has not changed.

> Unique: Kyes must only be unique among siblings

> Predictable: The should not be generated randomly

> Stable: The key for the same element should not be re-ordering elements

> > Better to use ID generated by databases or generate a hash of the content and use it as a key

```javascript
import shortid from "shortid";

const List = (props) => (
  <ul>
    {props.data.map((item) => (
      <li key={shortid.generate()}>{item}</li>
    ))}
  </ul>
);
```

[More details here](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318)

#### Unconditionally copying props to state

> Using props to generate state often leads to duplicatino of 'source of truth'. This is because getInitialState is only invoked when the component is first created. A common misconception is that <strong>getDerivedStateFromProps</strong> only called when props 'change', and called any time a parent component rerenders, regardless of whether the props are 'different' from before.

```javascript
class UrlInput extends Component {
  state = { url: this.props.url };
  handleChange = (e) => {
    this.setState({ url: e.target.value });
  };
  render() {
    return (
      <input type="url" onChange={this.handleChange} value={this.state.url} />
    );
  }
  componentWillReceiveProps(nextProps) {
    this.setState({ url: nextProps.url });
  }
}
```

> If our component's parent rerenders, anything we've typed into the <strong>input</strong> will be lost

[More details here](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state)

#### Erasing state when props change

```javascript
class UrlInput extends Component {
  state = { url: this.props.url };
  handleChange = (e) => {
    this.setState({ url: e.target.value });
  };
  render() {
    return (
      <input type="url" onChange={this.handleChange} value={this.state.url} />
    );
  }
  componentWillReceiveProps(nextProps) {
    if (nextProps.url !== this.props.url) {
      this.setState({ url: nextProps.url });
    }
  }
}
```

> Now our component will erase what we've typed only when the props actually change.

> > Solution for both cases above will be, for any piece of data, you need to pick a single component that owns it as the source of truth, and avoid duplicating it in other components.

```javascript
const UrlInput = (props) => (
  <input onChange={props.onChange} value={props.email} />
);
```

> > or

```javascript
<UrlInput defaultUrl={this.props.user.url} key={this.props.user.id} />
```

[More details here](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component)

#### Using state with shallow comparison

If you mutate the state directly, the component will not be re-render and the changes will not be reflected. The <strong>state</strong> is compared shallowly. You must use <b>setState</b> instead for changing the value of the state.

> The only place where you can assign <b>this.state</b> is the constructor!

> The <b>setState</b> function is asynchronous!

> The return value is merged in with the existing state to build the new state

> > You should use setState with callback

```javascript
this.setState((state, props) => {
  data: state.data + props.data;
});
```

[More details here](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous)
